<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Flashcards App — The Bookworm</title>
  <style>
    :root{--bg:#0f1724;--card:#f8fafc;--accent:#06b6d4;--muted:#94a3b8}
    body{font-family:Inter,system-ui,Arial;margin:0;background:linear-gradient(180deg,#071029 0%, #0b1220 100%);color:#e6eef6;display:flex;min-height:100vh;align-items:center;justify-content:center}
    .app{width:960px;max-width:96%;background:rgba(255,255,255,0.03);padding:18px;border-radius:12px;box-shadow:0 8px 30px rgba(2,6,23,0.6)}
    header{display:flex;gap:12px;align-items:center;margin-bottom:12px}
    header h1{margin:0;font-size:20px}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    .panel{display:flex;gap:12px}
    select,input,button{background:transparent;border:1px solid rgba(255,255,255,0.08);padding:8px;border-radius:8px;color:inherit}
    .grid{display:grid;grid-template-columns:1fr 320px;gap:14px}
    .card{background:var(--card);color:#021025;border-radius:10px;padding:24px;min-height:220px;display:flex;align-items:center;justify-content:center;font-size:20px;box-shadow:0 6px 20px rgba(2,6,23,0.45)}
    .card .side{max-width:100%;text-align:center}
    .meta{background:rgba(255,255,255,0.02);padding:12px;border-radius:8px;color:var(--muted)}
    .actions{display:flex;gap:8px;margin-top:10px}
    .small{font-size:13px;padding:6px}
    .library{display:flex;flex-direction:column;gap:8px}
    .collection-item{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:6px}
    .progress{height:8px;background:rgba(0,0,0,0.12);border-radius:4px;overflow:hidden}
    .progress > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#8b5cf6);width:0%}
    footer{margin-top:12px;font-size:12px;color:var(--muted)}
    @media(max-width:820px){.grid{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="app" id="app">
    <header>
      <h1>Flashcards — The Bookworm</h1>
      <div class="controls">
        <label>Mode:
          <select id="modeSelect">
            <option value="study">Study</option>
            <option value="review">Review (only unknown)</option>
            <option value="shuffle">Shuffle</option>
          </select>
        </label>
        <label>Library:
          <select id="librarySelect"><option value="__loading">Loading...</option></select>
        </label>
        <input type="file" id="fileInput" class="small" accept="application/json" title="Load single collection JSON (for offline use)" />
        <button id="importBtn" class="small">Import collection (download JSON)</button>
      </div>
    </header>

    <div class="grid">
      <main>
        <div class="card" id="card" tabindex="0">
          <div class="side" id="cardContent">No cards loaded. Choose a collection or drop a JSON file.</div>
        </div>

        <div class="actions">
          <button id="prevBtn">◀ Prev</button>
          <button id="flipBtn">Flip</button>
          <button id="nextBtn">Next ▶</button>
          <button id="shuffleBtn">Shuffle</button>
          <button id="markKnownBtn">Mark Known</button>
          <button id="markUnknownBtn">Mark Unknown</button>
        </div>

        <div class="meta" id="meta">
          <div>Card <span id="indexDisplay">0</span> / <span id="totalDisplay">0</span></div>
          <div class="progress" style="margin-top:8px"><i id="progressBar"></i></div>
        </div>
      </main>

      <aside>
        <div class="meta">
          <strong>Collections</strong>
          <div class="library" id="collectionList" style="margin-top:8px">
            <div>Loading library…</div>
          </div>
          <hr />
          <div style="margin-top:8px">
            <strong>Collection actions</strong>
            <div style="display:flex;gap:8px;margin-top:8px">
              <button id="exportBtn" class="small">Export JSON</button>
              <button id="resetProgressBtn" class="small">Reset progress</button>
            </div>
          </div>
        </div>

        <div class="meta" style="margin-top:12px">
          <strong>Hints & Shortcuts</strong>
          <ul>
            <li>Space / Enter — Flip</li>
            <li>← / → — Prev / Next</li>
            <li>K / U — Mark Known / Unknown</li>
            <li>Use file input to load local collection for offline mode</li>
          </ul>
        </div>
      </aside>
    </div>

    <footer>
      This is a single-file app. To host a library on your site, add a <code>library.json</code> and collection JSON files under <code>/flashcards/</code>. See docs below.
    </footer>
  </div>

  <script>
    // --- Configuration: where the website-hosted library lives
    const LIBRARY_INDEX = '/flashcards/library.json';

    // --- App state
    let collectionsIndex = []; // from library.json
    let currentCollection = null; // {id,title,cards:[]}
    let deck = []; // order of card indices
    let pos = 0;
    let showBack = false;

    // --- Helpers
    const el = id => document.getElementById(id);
    const saveProgressKey = id => `flashcards.progress.${id}`;

    // --- UI elements
    const librarySelect = el('librarySelect');
    const cardContent = el('cardContent');
    const indexDisplay = el('indexDisplay');
    const totalDisplay = el('totalDisplay');
    const progressBar = el('progressBar');
    const collectionList = el('collectionList');

    // --- Load remote library index (for website mode)
    async function loadLibraryIndex(){
      try{
        const r = await fetch(LIBRARY_INDEX, {cache:'no-cache'});
        if(!r.ok) throw new Error('No library.json');
        const json = await r.json();
        collectionsIndex = json.collections || [];
        renderLibraryOptions();
        renderCollectionList();
      }catch(err){
        console.warn('Could not load library index:', err);
        librarySelect.innerHTML = '<option value="__none">No remote library</option>';
        collectionList.innerHTML = '<div>No remote library found. Use file input to load a collection.</div>';
      }
    }

    function renderLibraryOptions(){
      librarySelect.innerHTML = '';
      const dflt = document.createElement('option'); dflt.value='__none'; dflt.textContent='Select a collection from site';
      librarySelect.appendChild(dflt);
      collectionsIndex.forEach(c=>{
        const o = document.createElement('option'); o.value = c.path || c.id; o.textContent = c.title || c.id; librarySelect.appendChild(o);
      });
    }

    function renderCollectionList(){
      collectionList.innerHTML = '';
      if(collectionsIndex.length===0){ collectionList.innerHTML = '<div>No collections in library.json</div>'; return; }
      collectionsIndex.forEach(c=>{
        const row = document.createElement('div'); row.className='collection-item';
        const left = document.createElement('div'); left.textContent = c.title || c.id;
        const right = document.createElement('div');
        const loadBtn = document.createElement('button'); loadBtn.textContent='Load'; loadBtn.onclick=()=>loadCollectionFromUrl(c.path||c.id);
        right.appendChild(loadBtn);
        row.appendChild(left); row.appendChild(right);
        collectionList.appendChild(row);
      });
    }

    // --- Load a collection JSON from a URL (website hosting)
    async function loadCollectionFromUrl(url){
      try{
        const r = await fetch(url, {cache:'no-cache'});
        if(!r.ok) throw new Error('Could not fetch collection');
        const data = await r.json();
        prepareCollection(data);
      }catch(err){
        alert('Failed to load collection: '+err.message);
      }
    }

    // --- Load collection from local file input (offline usage)
    el('fileInput').addEventListener('change', async e=>{
      const f = e.target.files[0]; if(!f) return;
      try{
        const text = await f.text(); const data = JSON.parse(text);
        prepareCollection(data);
      }catch(err){ alert('Invalid file: '+err.message); }
    });

    // --- Prepare collection object, expected format: {id,title,cards:[{front,back,meta?}, ...]}
    function prepareCollection(data){
      if(!data || !Array.isArray(data.cards)){
        alert('Collection JSON must be {id,title,cards:[{front,back}] }'); return;
      }
      currentCollection = {id: data.id||('col-'+Date.now()), title:data.title||'Untitled', cards:data.cards.map(c=>({front:c.front||'', back:c.back||'', meta:c.meta||{}})) };
      // build deck based on mode
      buildDeck();
      pos = 0; showBack=false; renderCard();
      // try to restore progress
      restoreProgress();
    }

    function buildDeck(){
      deck = currentCollection.cards.map((_,i)=>i);
      const mode = el('modeSelect').value;
      if(mode==='shuffle' || mode==='study') shuffleArray(deck);
      if(mode==='review') deck = deck.filter(i=> !isMarkedKnown(currentCollection.id,i));
      totalDisplay.textContent = deck.length;
    }

    function renderCard(){
      if(!currentCollection){ cardContent.textContent='No collection loaded.'; indexDisplay.textContent='0'; totalDisplay.textContent='0'; progressBar.style.width='0%'; return; }
      if(deck.length===0){ cardContent.textContent='No cards in this deck (maybe everything marked known).'; indexDisplay.textContent='0'; totalDisplay.textContent='0'; progressBar.style.width='100%'; return; }
      const idx = deck[pos]; const card = currentCollection.cards[idx];
      cardContent.innerHTML = `<div><div style="font-size:14px;color:var(--muted);margin-bottom:8px">${currentCollection.title}</div><div><strong>${escapeHtml(showBack ? card.back : card.front)}</strong></div></div>`;
      indexDisplay.textContent = (pos+1);
      totalDisplay.textContent = deck.length;
      const pct = Math.round(((pos+1)/deck.length)*100);
      progressBar.style.width = pct + '%';
      saveProgress();
    }

    function flipCard(){ showBack = !showBack; renderCard(); }
    function nextCard(){ if(!deck.length) return; pos = (pos+1)%deck.length; showBack=false; renderCard(); }
    function prevCard(){ if(!deck.length) return; pos = (pos-1+deck.length)%deck.length; showBack=false; renderCard(); }

    // --- Marking known/unknown
    function markKnown(){ if(!currentCollection||!deck.length) return; const idx = deck[pos]; setMarkedKnown(currentCollection.id, idx, true); // remove from deck in review mode
      if(el('modeSelect').value==='review') { deck.splice(pos,1); if(pos>=deck.length) pos=0; }
      renderCard(); }
    function markUnknown(){ if(!currentCollection||!deck.length) return; const idx = deck[pos]; setMarkedKnown(currentCollection.id, idx, false); renderCard(); }

    // --- localStorage helpers for progress & known flags
    function saveProgress(){ if(!currentCollection) return; const key = saveProgressKey(currentCollection.id); const payload = {pos,deck,known:getKnownMap(currentCollection.id)}; try{ localStorage.setItem(key,JSON.stringify(payload)); }catch(e){}
    }
    function restoreProgress(){ if(!currentCollection) return; const key = saveProgressKey(currentCollection.id); try{ const raw = localStorage.getItem(key); if(!raw) return; const p = JSON.parse(raw); if(p.deck && p.deck.length>0){ deck = p.deck; pos = Math.min(p.pos||0, deck.length-1); } }catch(e){}
    }

    // known map stored separately
    function knownStorageKey(colId){ return `flashcards.known.${colId}`; }
    function getKnownMap(colId){ try{ return JSON.parse(localStorage.getItem(knownStorageKey(colId))||'{}'); }catch(e){return{}} }
    function isMarkedKnown(colId, index){ const map = getKnownMap(colId); return !!map[index]; }
    function setMarkedKnown(colId,index,val){ const map = getKnownMap(colId); if(val) map[index]=true; else delete map[index]; localStorage.setItem(knownStorageKey(colId),JSON.stringify(map)); }

    function getKnownPercentage(){ if(!currentCollection) return 0; const map = getKnownMap(currentCollection.id); const knownCount = Object.keys(map).length; return Math.round((knownCount/currentCollection.cards.length)*100); }

    // --- Utilities
    function shuffleArray(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }
    function escapeHtml(s){ return (s+'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\n/g,'<br>'); }

    // --- Export / Import
    el('exportBtn').addEventListener('click', ()=>{
      if(!currentCollection) return alert('Load a collection first');
      const blob = new Blob([JSON.stringify(currentCollection, null, 2)],{type:'application/json'});
      const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download = `${currentCollection.id||'collection'}.json`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    });

    el('importBtn').addEventListener('click', ()=>{
      if(!currentCollection) return alert('Load a collection first');
      // trigger export for edit/upload — same as export
      el('exportBtn').click();
    });

    el('resetProgressBtn').addEventListener('click', ()=>{
      if(!currentCollection) return; if(!confirm('Reset progress & known marks for this collection?')) return; localStorage.removeItem(saveProgressKey(currentCollection.id)); localStorage.removeItem(knownStorageKey(currentCollection.id)); buildDeck(); pos=0; renderCard(); });

    // --- Buttons and keyboard
    el('flipBtn').addEventListener('click', flipCard);
    el('nextBtn').addEventListener('click', nextCard);
    el('prevBtn').addEventListener('click', prevCard);
    el('shuffleBtn').addEventListener('click', ()=>{ shuffleArray(deck); pos=0; renderCard(); });
    el('markKnownBtn').addEventListener('click', markKnown);
    el('markUnknownBtn').addEventListener('click', markUnknown);

    document.addEventListener('keydown', e=>{
      if(e.key===' '||e.key==='Enter'){ e.preventDefault(); flipCard(); }
      if(e.key==='ArrowRight') nextCard();
      if(e.key==='ArrowLeft') prevCard();
      if(e.key.toLowerCase()==='k') markKnown();
      if(e.key.toLowerCase()==='u') markUnknown();
    });

    // Library select change
    librarySelect.addEventListener('change', ()=>{
      const v = librarySelect.value; if(!v||v==='__none') return; loadCollectionFromUrl(v);
    });

    // init
    loadLibraryIndex();

    // make app focusable
    el('card').addEventListener('click', ()=>{ flipCard(); });
  </script>
</body>
</html>
